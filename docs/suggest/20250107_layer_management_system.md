# レイヤー管理システム実装提案

## 作成日
2025-01-07

## 要望サマリー

### 何を
画像ビューアに**レイヤー管理システム**を導入し、複数の視覚効果（フォーカスピーキング、グリッド等）を階層的に管理する機能

### なぜ
- 現在のグリッドオーバーレイが画像に直接重なっている構造を改善
- フォーカスピーキング（ピント合わせ支援）など複数のレイヤーを追加予定
- 各レイヤーのON/OFF管理を一元化し、可読性と保守性を向上
- 最大5層のレイヤーを扱える拡張性を確保

### どう（ユーザー提案の実装方法）
1. **画像 → ピーキング処理 → グリッド処理** の順でレイヤーを重ねる
2. **ImageManager.tsx** を新規作成し、レイヤー管理を集約
3. 各レイヤーの状態（ON/OFF、不透明度、色など）をImageManagerで管理
4. フォーカスピーキングはRust側で処理（1秒程度の処理時間は許容）
5. リアルタイムで強度調整可能、毎回再生成方式

## 確定した実装方針

### 採用方法
**SVGベクター方式によるレイヤー管理システム**

### 採用理由
1. **ズーム追従性**: SVGはベクター形式のため、画像を拡大してもエッジが荒れない
2. **データ効率**: PNG画像と比較して、座標データのみで済むため軽量
3. **アニメーション対応**: CSS/SVG Animationで点滅・発光効果を容易に実装可能
4. **パフォーマンス**: 高解像度PNG（4倍サイズなど）と比較してメモリ消費が少ない
5. **将来拡張性**: 最大5層まで対応可能な設計

### 主要な技術選択

#### フレームワーク/ライブラリ
- **Frontend**: SolidJS (既存) - リアクティブなレイヤー管理
- **Backend**: Rust + Tauri (既存) - 画像処理エンジン
- **画像処理**: `image` クレート (既存) - エッジ検出処理
- **描画**: SVG (新規) - ベクターベースのエッジ描画

#### アーキテクチャパターン
- **コンポジションパターン**: ImageManagerが子レイヤーコンポーネントを統括
- **Context API**: AppStateContextでグローバル状態管理
- **Command Pattern**: Tauri Commandでフロント-バックエンド通信

#### 状態管理
- **AppStateContext拡張**: 既存のgridPattern/gridOpacity方式を踏襲
- **新規追加状態**:
  - `peakingEnabled: boolean` - ピーキングON/OFF
  - `peakingIntensity: number` - エッジ検出閾値 (0-255)
  - `peakingColor: string` - 表示色（デフォルト: "lime"）
  - `peakingOpacity: number` - 不透明度（デフォルト: 0.5）

## 大まかな実装内容

### 何をするか

1. **Rustフォーカスピーキング実装**
   - Sobelフィルタによるエッジ検出
   - 閾値処理で強度調整
   - エッジ座標リストをJSON形式で返却

2. **ImageManager.tsx作成**
   - 画像とレイヤーの統合管理
   - 各レイヤーコンポーネントのレンダリング
   - transform（ズーム・パン・回転）の一元管理

3. **PeakingLayer.tsx作成**
   - SVG polylineでエッジ描画
   - CSS Animationによる視覚効果（点滅・発光）
   - Rust処理結果のキャッシュ管理

4. **AppStateContext拡張**
   - ピーキング関連の状態追加
   - Tauri Commandの呼び出しロジック

5. **GridOverlay.tsx移行**
   - ImageManagerの子コンポーネントとして配置
   - 既存機能は維持

### 影響を受ける領域

#### 新規作成が必要なもの
- `src/components/ImageViewer/ImageManager.tsx` - レイヤー統合管理
- `src/components/ImageViewer/PeakingLayer.tsx` - SVGピーキング描画
- `src-tauri/src/peaking.rs` - フォーカスピーキング処理
- `docs/20250107_layer_management_system/` - 実装計画ドキュメント

#### 変更が必要なもの
- `src/components/ImageViewer/index.tsx` - ImageManager統合
- `src/context/AppStateContext.tsx` - 状態拡張
- `src-tauri/src/lib.rs` - peakingモジュール登録
- `src/components/ImageViewer/GridOverlay.tsx` - 軽微な調整（オプション）

## 実装の制約条件

### 技術的制約
- **処理時間**: Rustピーキング処理は1秒程度まで許容（リアルタイム性重視だが猶予あり）
- **レイヤー数**: 最大5層を想定した設計
- **ズーム範囲**: 既存のCONFIG.zoom（50%〜500%）に追従
- **ブラウザ互換性**: SVG対応ブラウザ（モダンブラウザ全般）

### ビジネス制約
- **既存機能維持**: グリッドオーバーレイの既存動作を変更しない
- **パフォーマンス**: VRゴーグル使用を考慮し、60fps維持を目指す

### スケジュール制約
- **段階的実装**: 基盤 → ピーキング → UI拡張の順で実装
- **テスト**: 各チケット完了時に動作確認

## リスクと対策

### リスク1: エッジ座標数が多すぎてSVG描画が重くなる
**対策**: 
- Douglas-Peuckerアルゴリズムで座標を間引き
- 閾値を調整してエッジ数を制限

### リスク2: 画像変更時のピーキング生成待ち時間
**対策**:
- ローディングインジケーター表示
- 前回結果をキャッシュして即座に表示

### リスク3: レイヤー数増加によるメンテナンス性低下
**対策**:
- ImageManagerで統一的なインターフェース設計
- 各レイヤーを独立したコンポーネントとして疎結合化

## 検討した代替案

### 案1: 高解像度PNG方式
**メリット**:
- 実装がシンプル
- 既存のimg要素で扱える

**デメリット**:
- データ量が大きい（4倍解像度で16倍のデータ）
- ズーム時に荒れる可能性
- メモリ消費が多い

**不採用理由**: VRゴーグル環境でのパフォーマンスとズーム追従性を優先

### 案2: Canvas 2D描画
**メリット**:
- ピクセル単位の細かい制御が可能
- 既存GridOverlayと同様のアプローチ

**デメリット**:
- ズーム時に再描画が必要
- アニメーションの実装が複雑

**不採用理由**: SVGの方がズーム追従とアニメーションが容易

### 案3: WebGL Shader
**メリット**:
- 最高のパフォーマンス
- リアルタイムエフェクト可能

**デメリット**:
- 実装コストが高い
- オーバーエンジニアリング

**不採用理由**: 現時点での要件に対して過剰

## 次のステップ
この提案を基にPlan phaseで詳細な実装計画とチケットを作成します。
